
<!DOCTYPE html>
<html lang="de">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <meta name="theme-color" content="#0a0e14">
    <title>BLE INDUSTRIAL — TARGET: YVES</title>
    <link href="https://fonts.googleapis.com/css2?family=JetBrains+Mono:wght@300;400;600;700;800&family=IBM+Plex+Sans:wght@400;500;600&display=swap" rel="stylesheet">
    <style>
        :root {
            --bg:      #060a10;
            --surface: #0c1118;
            --card:    #111820;
            --border:  #1a2535;
            --border2: #243040;
            --neon:    #00ff9f;
            --target:  #ff00ff;
            --blue:    #38bdf8;
            --amber:   #fbbf24;
            --red:     #ef4444;
            --orange:  #f97316;
            --text:    #c8d6e5;
            --dim:     #4a5a6a;
            --mono:    'JetBrains Mono', monospace;
            --ui:      'IBM Plex Sans', sans-serif;
            --r:       6px;
        }
        *{box-sizing:border-box;margin:0;padding:0}
        html,body{height:100%;overflow:hidden}
        body{background:var(--bg);color:var(--text);font-family:var(--ui)}
        #app{display:flex;flex-direction:column;height:100dvh}

        /* ─── TOPBAR ─── */
        #topbar{
            padding:10px 16px;background:var(--surface);
            border-bottom:1px solid var(--border);
            display:flex;align-items:center;justify-content:space-between;
            flex-shrink:0;
        }
        #topbar h1{font-family:var(--mono);font-size:12px;color:var(--neon);letter-spacing:2px;font-weight:700}
        .pill{
            font-family:var(--mono);font-size:9px;font-weight:600;
            padding:3px 10px;border-radius:20px;
            background:rgba(255,255,255,0.03);border:1px solid var(--border);
            color:var(--dim);text-transform:uppercase;letter-spacing:1px;
            transition:all .3s;
        }
        .pill.scanning{color:var(--amber);border-color:var(--amber);animation:pulse 1.2s infinite}
        .pill.target{color:var(--target);border-color:var(--target);animation:pulse .6s infinite;box-shadow:0 0 12px rgba(255,0,255,.2)}
        .pill.connected{color:var(--neon);border-color:var(--neon);box-shadow:0 0 8px rgba(0,255,159,.15)}
        @keyframes pulse{0%,100%{opacity:1}50%{opacity:.4}}

        /* ─── CONTENT ─── */
        #content{flex:1;overflow-y:auto;-webkit-overflow-scrolling:touch}
        .tab{display:none;padding:12px 14px}
        .tab.active{display:block}

        /* ─── BUTTONS ─── */
        .btn{
            width:100%;padding:12px;border-radius:var(--r);
            font-family:var(--mono);font-size:11px;font-weight:600;
            text-transform:uppercase;letter-spacing:1px;cursor:pointer;
            border:1px solid var(--neon);color:var(--neon);
            background:rgba(0,255,159,.04);
            -webkit-tap-highlight-color:transparent;
            transition:background .15s;
        }
        .btn:active{background:rgba(0,255,159,.12)}
        .btn.stop{border-color:var(--red);color:var(--red);background:rgba(239,68,68,.04)}
        .btn.stop:active{background:rgba(239,68,68,.12)}
        .btn.accent{border-color:var(--target);color:var(--target);background:rgba(255,0,255,.04)}
        .btn:disabled{opacity:.25;pointer-events:none}
        .btn-grid{display:grid;gap:8px;margin-bottom:10px}
        .btn-grid.c2{grid-template-columns:1fr 1fr}

        /* ─── SCAN STATS BAR ─── */
        .stats-bar{
            display:flex;justify-content:space-between;
            font-family:var(--mono);font-size:9px;color:var(--dim);
            padding:6px 2px;border-bottom:1px solid var(--border);
            margin-bottom:8px;
        }
        .stats-bar .v{color:var(--text)}
        .stats-bar .t{color:var(--target);font-weight:700}

        /* ─── DEVICE LIST ─── */
        #devices{display:flex;flex-direction:column;gap:6px}

        .dev{
            background:var(--card);border:1px solid var(--border);
            border-radius:var(--r);padding:10px 12px;
            position:relative;transition:all .25s;
        }
        .dev.stale{opacity:.35}
        .dev.is-target{
            order:-1;
            border:1.5px solid var(--target);
            background:linear-gradient(135deg,rgba(255,0,255,.04),rgba(255,0,255,.01));
            box-shadow:0 0 20px rgba(255,0,255,.08);
            cursor:pointer;
        }
        .dev.is-target:active{background:rgba(255,0,255,.1)}
        .dev.is-target .tag-target{
            position:absolute;top:-8px;left:10px;
            background:var(--target);color:#fff;
            font-family:var(--mono);font-size:7px;font-weight:800;
            padding:2px 7px;border-radius:3px;letter-spacing:.5px;
        }
        .dev.is-connected{
            border-color:var(--neon);
            box-shadow:0 0 15px rgba(0,255,159,.1);
        }
        .dev.is-connected .tag-target{background:var(--neon);color:#000}

        .dev-top{display:flex;justify-content:space-between;align-items:flex-start;gap:8px}
        .dev-name{font-family:var(--mono);font-weight:600;color:#fff;font-size:12px;word-break:break-all}
        .dev-name.none{color:var(--dim);font-style:italic;font-weight:400}
        .dev-rssi{font-family:var(--mono);font-weight:800;font-size:13px;white-space:nowrap;flex-shrink:0}

        .signal-bar{height:3px;border-radius:2px;margin:6px 0 4px;transition:width .4s,background .4s}

        .dev-row{display:flex;flex-wrap:wrap;gap:4px 10px;margin-top:3px}
        .dev-tag{
            font-family:var(--mono);font-size:8px;font-weight:600;
            padding:1px 5px;border-radius:3px;
            background:rgba(255,255,255,.05);color:var(--dim);
        }
        .dev-tag.mfr{color:var(--amber);background:rgba(251,191,36,.08)}
        .dev-tag.svc{color:var(--blue);background:rgba(56,189,248,.08)}
        .dev-tag.id{color:var(--dim)}
        .dev-tag.cnt{color:var(--text)}

        .dev-action{
            display:block;margin-top:6px;
            font-family:var(--mono);font-size:8px;font-weight:700;
            color:var(--target);letter-spacing:1px;text-transform:uppercase;
        }

        /* ─── GATT ─── */
        .gatt-box{
            background:var(--card);border:1px solid var(--border);
            border-radius:var(--r);padding:10px 12px;margin-bottom:8px;
            font-family:var(--mono);font-size:10px;line-height:1.8;
        }
        .gatt-box .lbl{color:var(--dim)}
        .gatt-box .val{color:#fff}
        .gatt-box .val.on{color:var(--neon)}
        .gatt-box .val.tgt{color:var(--target)}

        .gatt-svc{
            border:1px solid var(--border);border-radius:var(--r);
            margin-bottom:8px;overflow:hidden;background:#000;
        }
        .gatt-svc-head{
            padding:8px 10px;background:var(--surface);
            font-family:var(--mono);font-size:10px;color:var(--blue);font-weight:600;
        }
        .gatt-svc-head small{display:block;font-size:8px;color:var(--dim);font-weight:400;margin-top:2px;word-break:break-all}

        .gatt-char{
            padding:8px 10px;border-top:1px solid var(--border);
            font-family:var(--mono);font-size:10px;
        }
        .gatt-char-name{font-weight:600;color:#fff}
        .gatt-char-flags{font-size:8px;color:var(--amber);margin-top:2px}
        .gatt-char-uuid{font-size:8px;color:var(--dim);margin-top:1px;word-break:break-all}
        .gatt-val{
            display:block;margin-top:4px;padding:5px 6px;
            background:var(--bg);border-radius:4px;
            color:var(--neon);font-size:9px;line-height:1.6;
            overflow-wrap:anywhere;min-height:20px;
        }
        .badge{
            display:inline-block;font-size:7px;font-weight:700;
            padding:1px 4px;border-radius:2px;margin-left:4px;
            vertical-align:middle;letter-spacing:.3px;
        }
        .badge.notify{background:var(--target);color:#fff}
        .badge.indicate{background:var(--orange);color:#fff}

        /* ─── LOG ─── */
        .log-line{font-family:var(--mono);font-size:9px;padding:3px 0;border-bottom:1px solid rgba(255,255,255,.03);line-height:1.5}
        .log-line.t{color:var(--target);font-weight:600}
        .log-line.e{color:var(--red)}
        .log-line.w{color:var(--amber)}

        /* ─── NAVBAR ─── */
        #nav{
            display:grid;grid-template-columns:repeat(3,1fr);
            background:var(--surface);border-top:1px solid var(--border);
            padding-bottom:env(safe-area-inset-bottom);flex-shrink:0;
        }
        .nav-b{
            padding:11px 8px;border:none;background:transparent;
            color:var(--dim);font-family:var(--mono);font-size:9px;
            font-weight:600;text-transform:uppercase;letter-spacing:1px;
            -webkit-tap-highlight-color:transparent;
            border-top:2px solid transparent;transition:all .2s;
        }
        .nav-b.on{color:var(--neon);border-top-color:var(--neon)}

        .note{
            font-family:var(--mono);font-size:9px;color:var(--dim);
            padding:8px 10px;border:1px dashed var(--border);border-radius:var(--r);
            margin-bottom:10px;line-height:1.8;
        }
        .note code{color:var(--amber);font-weight:600}
        .note em{color:var(--text);font-style:normal}
    </style>
</head>
<body>
<div id="app">
    <div id="topbar">
        <h1>BLE // YVES</h1>
        <div class="pill" id="pill">IDLE</div>
    </div>

    <div id="content">
        <!-- ══ SCAN ══ -->
        <div class="tab active" id="tab-scan">
            <div class="note" id="scan-note">
                Passiver BLE-Scan via <code>requestLEScan()</code><br>
                Flag: <code>chrome://flags/#enable-experimental-web-platform-features</code><br>
                <em>JBL-Geräte werden automatisch erkannt — antippen zum Verbinden.</em>
            </div>
            <div class="btn-grid c2">
                <button class="btn" id="btn-start" onclick="App.startScan()">▶ Scan</button>
                <button class="btn stop" id="btn-stop" onclick="App.stopScan()" disabled>■ Stop</button>
            </div>
            <div class="stats-bar" id="stats" style="display:none">
                <span>Geräte: <span class="v" id="s-total">0</span></span>
                <span>Targets: <span class="t" id="s-target">0</span></span>
                <span>Pakete: <span class="v" id="s-pkts">0</span></span>
                <span>Rate: <span class="v" id="s-rate">0</span>/s</span>
            </div>
            <div id="devices"></div>
        </div>

        <!-- ══ GATT ══ -->
        <div class="tab" id="tab-gatt">
            <div class="gatt-box" id="gatt-info">
                <span class="lbl">Status:</span> <span class="val" id="g-state">Nicht verbunden</span><br>
                <span class="lbl">Gerät:</span> <span class="val" id="g-name">—</span><br>
                <span class="lbl">Services:</span> <span class="val" id="g-svcs">—</span>
                <span class="lbl"> Notify:</span> <span class="val" id="g-notify">—</span>
            </div>
            <button class="btn stop" id="btn-dc" onclick="App.disconnect()" disabled>Disconnect</button>
            <div id="gatt-list" style="margin-top:10px"></div>
        </div>

        <!-- ══ LOG ══ -->
        <div class="tab" id="tab-log">
            <div class="btn-grid c2">
                <button class="btn" onclick="App.exportLog()">Export</button>
                <button class="btn stop" onclick="App.clearLog()">Clear</button>
            </div>
            <div id="log-list"></div>
        </div>
    </div>

    <div id="nav">
        <button class="nav-b on" data-t="tab-scan" onclick="App.tab(this)">Radar</button>
        <button class="nav-b" data-t="tab-gatt" onclick="App.tab(this)">GATT</button>
        <button class="nav-b" data-t="tab-log" onclick="App.tab(this)">Log</button>
    </div>
</div>

<script>
const App = (() => {
    'use strict';

    /* ═══════════════════════════════════════════════
       STATE
    ═══════════════════════════════════════════════ */
    const S = {
        devs: new Map(),          // id → DeviceEntry
        scan: null,               // BleScanHandle
        scanning: false,
        pktCount: 0,
        pktLast: 0,
        pktRate: 0,
        rateTimer: null,

        gattServer: null,
        gattDevice: null,
        connId: null,
        notifySubs: [],
        logs: [],
    };

    /* ═══════════════════════════════════════════════
       DEVICE ENTRY SHAPE
    ═══════════════════════════════════════════════ */
    // { device, names: Set, bestName, rssi, txPower,
    //   mfr: Map<companyId, {name,hex}>, svcUuids: Set, svcData: Map,
    //   isTarget, firstSeen, lastSeen, count, stale }

    /* ═══════════════════════════════════════════════
       KNOWN DATABASE
    ═══════════════════════════════════════════════ */
    const MFR_DB = {
        0x0057:'Harman/JBL', 0x004C:'Apple', 0x0006:'Microsoft',
        0x00E0:'Google', 0x0075:'Samsung', 0x0059:'Nordic',
        0x000D:'TI', 0x000F:'Broadcom', 0x0003:'IBM',
        0x001D:'Qualcomm', 0x0046:'MediaTek', 0x0087:'Garmin',
        0x02FF:'Xiaomi',
    };

    // JBL / Harman Identifikation — mehrere Methoden
    const TARGET_MFR_IDS = new Set([0x0057]);   // Harman International
    const TARGET_SVC_UUIDS = new Set([
        '0000fe61-0000-1000-8000-00805f9b34fb',  // JBL custom
    ]);
    const TARGET_NAME_PATTERNS = [
        /jbl/i, /yves/i, /harman/i,
        /flip/i, /charge/i, /pulse/i, /xtreme/i, /boombox/i,
        /clip/i, /go\s?\d/i, /tune/i, /live/i, /endurance/i,
        /reflect/i, /quantum/i, /tour/i, /partybox/i,
    ];

    // Services für GATT-Zugriff anfordern
    const OPT_SERVICES = [
        'generic_access','generic_attribute','device_information',
        'battery_service','tx_power','immediate_alert','link_loss',
        'human_interface_device',
        0xFE61, 0xFEA0, 0xFE07, 0xFE08, 0xFEB2,
    ];

    const SVC_NAMES = {
        '00001800':'Generic Access','00001801':'Generic Attribute',
        '0000180a':'Device Information','0000180f':'Battery',
        '00001804':'TX Power','00001802':'Immediate Alert',
        '00001803':'Link Loss','00001812':'HID',
        '0000fe61':'JBL Custom','0000fea0':'Google Fast Pair',
    };
    const CHAR_NAMES = {
        '2a00':'Device Name','2a01':'Appearance','2a04':'Conn Params',
        '2a05':'Service Changed','2a19':'Battery Level','2a23':'System ID',
        '2a24':'Model Number','2a25':'Serial Number','2a26':'Firmware Rev',
        '2a27':'Hardware Rev','2a28':'Software Rev','2a29':'Manufacturer',
        '2a50':'PnP ID','2a07':'TX Power Level','2a06':'Alert Level',
    };

    /* ═══════════════════════════════════════════════
       LOGGING
    ═══════════════════════════════════════════════ */
    function log(msg, type = '') {
        const ts = new Date().toLocaleTimeString('de-DE', {hour:'2-digit',minute:'2-digit',second:'2-digit',fractionalSecondDigits:1});
        S.logs.push({ts, msg, type});
        const el = document.createElement('div');
        el.className = `log-line ${type === 'target' ? 't' : type === 'error' ? 'e' : type === 'warn' ? 'w' : ''}`;
        el.textContent = `${ts}  ${msg}`;
        document.getElementById('log-list').prepend(el);
        // Cap log DOM at 500
        const c = document.getElementById('log-list');
        while (c.children.length > 500) c.removeChild(c.lastChild);
    }

    /* ═══════════════════════════════════════════════
       TABS
    ═══════════════════════════════════════════════ */
    function tab(btn) {
        document.querySelectorAll('.tab').forEach(t => t.classList.remove('active'));
        document.querySelectorAll('.nav-b').forEach(b => b.classList.remove('on'));
        document.getElementById(btn.dataset.t).classList.add('active');
        btn.classList.add('on');
    }
    function goTab(id) {
        document.querySelectorAll('.tab').forEach(t => t.classList.remove('active'));
        document.querySelectorAll('.nav-b').forEach(b => b.classList.remove('on'));
        document.getElementById(id).classList.add('active');
        document.querySelector(`[data-t="${id}"]`).classList.add('on');
    }

    /* ═══════════════════════════════════════════════
       TARGET DETECTION (multi-method)
    ═══════════════════════════════════════════════ */
    function checkTarget(names, mfrIds, svcUuids) {
        // 1) Name patterns
        for (const n of names) {
            if (!n) continue;
            for (const re of TARGET_NAME_PATTERNS) {
                if (re.test(n)) return true;
            }
        }
        // 2) Manufacturer IDs
        for (const id of mfrIds) {
            if (TARGET_MFR_IDS.has(id)) return true;
        }
        // 3) Service UUIDs
        for (const uuid of svcUuids) {
            if (TARGET_SVC_UUIDS.has(uuid)) return true;
        }
        return false;
    }

    /* ═══════════════════════════════════════════════
       SIGNAL HELPERS
    ═══════════════════════════════════════════════ */
    function rssiPct(r) { return r == null ? 0 : Math.max(0, Math.min(100, ((r + 100) / 70) * 100)); }
    function rssiCol(r) {
        if (r == null) return '#333';
        if (r > -50) return '#00ff9f';
        if (r > -65) return '#a3e635';
        if (r > -75) return '#fbbf24';
        if (r > -85) return '#f97316';
        return '#ef4444';
    }

    /* ═══════════════════════════════════════════════
       PASSIVE SCAN
    ═══════════════════════════════════════════════ */
    async function startScan() {
        if (!navigator.bluetooth) return alert('Web Bluetooth nicht verfügbar.');
        if (!navigator.bluetooth.requestLEScan) {
            return alert('requestLEScan() fehlt!\n\nAktiviere:\nchrome://flags/#enable-experimental-web-platform-features\n\nChrome neu starten.');
        }
        try {
            log('Scan wird gestartet…');
            S.scan = await navigator.bluetooth.requestLEScan({ acceptAllAdvertisements: true });
            S.scanning = true;
            S.pktCount = 0;
            S.pktLast = performance.now();
            navigator.bluetooth.addEventListener('advertisementreceived', onAdv);
            // Packet-Rate Timer
            S.rateTimer = setInterval(calcRate, 1000);
            // Stale-Check Timer
            S.staleTimer = setInterval(markStale, 3000);
            updateScanUI();
            log('Scan aktiv — empfange Advertisements.', 'target');
        } catch (e) {
            log(`Scan-Fehler: ${e.message}`, 'error');
        }
    }

    function stopScan() {
        if (S.scan) { S.scan.stop(); S.scan = null; }
        S.scanning = false;
        navigator.bluetooth.removeEventListener('advertisementreceived', onAdv);
        clearInterval(S.rateTimer);
        clearInterval(S.staleTimer);
        updateScanUI();
        log('Scan gestoppt.');
    }

    function calcRate() {
        const now = performance.now();
        const dt = (now - S.pktLast) / 1000;
        S.pktRate = dt > 0 ? Math.round(S.pktCount / dt) : 0;
        // Reset for next window
        S.pktCount = 0;
        S.pktLast = now;
        const el = document.getElementById('s-rate');
        if (el) el.textContent = S.pktRate;
    }

    function markStale() {
        const now = Date.now();
        let changed = false;
        S.devs.forEach((d, id) => {
            const wasStale = d.stale;
            d.stale = (now - d.lastSeen) > 8000; // 8s kein Signal → stale
            if (d.stale !== wasStale) {
                changed = true;
                renderCard(id);
            }
        });
    }

    function updateScanUI() {
        const on = S.scanning;
        document.getElementById('btn-start').disabled = on;
        document.getElementById('btn-stop').disabled = !on;
        document.getElementById('stats').style.display = on ? 'flex' : 'none';
        document.getElementById('scan-note').style.display = on ? 'none' : 'block';
        updatePill();
    }

    function updatePill() {
        const p = document.getElementById('pill');
        if (S.gattServer && S.gattServer.connected) {
            p.textContent = 'CONNECTED'; p.className = 'pill connected';
        } else if (S.scanning) {
            let hasTgt = false;
            S.devs.forEach(d => { if (d.isTarget && !d.stale) hasTgt = true; });
            if (hasTgt) { p.textContent = 'TARGET'; p.className = 'pill target'; }
            else { p.textContent = 'SCANNING'; p.className = 'pill scanning'; }
        } else {
            p.textContent = 'IDLE'; p.className = 'pill';
        }
    }

    /* ═══════════════════════════════════════════════
       ADVERTISEMENT HANDLER
    ═══════════════════════════════════════════════ */
    // Throttle rendering: max 1 render per device per 300ms
    const _renderTimers = new Map();

    function onAdv(ev) {
        S.pktCount++;
        const dev = ev.device;
        const id = dev.id;
        const now = Date.now();

        // Existing or new entry
        let entry = S.devs.get(id);
        const isNew = !entry;

        if (isNew) {
            entry = {
                device: dev,
                names: new Set(),
                bestName: null,
                rssi: null,
                txPower: null,
                mfr: new Map(),
                svcUuids: new Set(),
                svcData: new Map(),
                isTarget: false,
                firstSeen: now,
                lastSeen: now,
                count: 0,
                stale: false,
            };
            S.devs.set(id, entry);
        }

        // ── Collect ALL name sources ──
        // Web Bluetooth liefert Namen unzuverlässig —
        // wir sammeln aus allen verfügbaren Quellen
        if (dev.name) entry.names.add(dev.name);
        if (ev.name) entry.names.add(ev.name);
        // Lokaler Name aus Scan-Response (manche Browser)
        if (ev.localName) entry.names.add(ev.localName);

        // Bester Name: längster nicht-leerer
        entry.bestName = resolveBestName(entry.names);

        // ── RSSI & TX Power ──
        if (ev.rssi != null) entry.rssi = ev.rssi;
        if (ev.txPower != null) entry.txPower = ev.txPower;

        // ── Manufacturer Data ──
        if (ev.manufacturerData && ev.manufacturerData.size > 0) {
            ev.manufacturerData.forEach((dv, companyId) => {
                const bytes = safeBytes(dv);
                const hex = bytesToHex(bytes);
                entry.mfr.set(companyId, {
                    label: MFR_DB[companyId] || `0x${companyId.toString(16).padStart(4,'0').toUpperCase()}`,
                    hex,
                    raw: bytes
                });
            });
        }

        // ── Service UUIDs ──
        if (ev.uuids && ev.uuids.length > 0) {
            ev.uuids.forEach(u => entry.svcUuids.add(String(u)));
        }

        // ── Service Data ──
        if (ev.serviceData && ev.serviceData.size > 0) {
            ev.serviceData.forEach((dv, uuid) => {
                entry.svcData.set(String(uuid), bytesToHex(safeBytes(dv)));
            });
        }

        entry.lastSeen = now;
        entry.count++;
        entry.stale = false;

        // ── Target Detection (re-evaluate every time — name might arrive later!) ──
        const wasTarget = entry.isTarget;
        entry.isTarget = checkTarget(entry.names, [...entry.mfr.keys()], entry.svcUuids);

        if (entry.isTarget && !wasTarget) {
            log(`★ TARGET ERKANNT: "${entry.bestName || id}" [RSSI: ${entry.rssi}]`, 'target');
            if (navigator.vibrate) navigator.vibrate([150, 80, 150, 80, 300]);
            updatePill();
        }

        // ── Stats ──
        let totalPkts = 0;
        let tgtCount = 0;
        S.devs.forEach(d => { totalPkts += d.count; if (d.isTarget) tgtCount++; });
        document.getElementById('s-total').textContent = S.devs.size;
        document.getElementById('s-target').textContent = tgtCount;
        document.getElementById('s-pkts').textContent = totalPkts;

        // ── Throttled render ──
        if (!_renderTimers.has(id)) {
            _renderTimers.set(id, setTimeout(() => {
                _renderTimers.delete(id);
                renderCard(id);
            }, isNew ? 0 : 300));
        }
    }

    function resolveBestName(nameSet) {
        if (nameSet.size === 0) return null;
        let best = null;
        for (const n of nameSet) {
            if (!n || !n.trim()) continue;
            if (!best || n.length > best.length) best = n;
        }
        return best;
    }

    /* ═══════════════════════════════════════════════
       DEVICE CARD RENDERING
    ═══════════════════════════════════════════════ */
    function renderCard(id) {
        const d = S.devs.get(id);
        if (!d) return;

        let card = document.querySelector(`[data-id="${id}"]`);
        if (!card) {
            card = document.createElement('div');
            card.dataset.id = id;
            document.getElementById('devices').appendChild(card);
        }

        const isCon = S.connId === id;
        const cls = ['dev'];
        if (d.isTarget) cls.push('is-target');
        if (isCon) cls.push('is-connected');
        if (d.stale) cls.push('stale');
        card.className = cls.join(' ');

        // Click handler nur für targets
        if (d.isTarget && !isCon) {
            card.onclick = () => connectDevice(id);
        } else {
            card.onclick = null;
        }

        const name = d.bestName;
        const pct = rssiPct(d.rssi);
        const col = rssiColor(d.rssi);

        // Tags
        let tags = '';

        // Manufacturer tags
        d.mfr.forEach((m, cid) => {
            tags += `<span class="dev-tag mfr" title="Company: 0x${cid.toString(16).padStart(4,'0')}">${m.label}</span>`;
        });

        // Service UUID tags
        d.svcUuids.forEach(u => {
            tags += `<span class="dev-tag svc">${shortUUID(u)}</span>`;
        });

        // Count tag
        tags += `<span class="dev-tag cnt">×${d.count}</span>`;

        // ID tag
        tags += `<span class="dev-tag id">${id.substring(0, 16)}</span>`;

        // Manufacturer data hex (für Targets anzeigen)
        let mfrHex = '';
        if (d.isTarget && d.mfr.size > 0) {
            d.mfr.forEach((m) => {
                mfrHex += `<div style="font-family:var(--mono);font-size:8px;color:var(--amber);margin-top:3px;opacity:.7">DATA: ${m.hex}</div>`;
            });
        }

        // Service Data hex
        let svcDataHex = '';
        if (d.isTarget && d.svcData.size > 0) {
            d.svcData.forEach((hex, uuid) => {
                svcDataHex += `<div style="font-family:var(--mono);font-size:8px;color:var(--blue);margin-top:2px;opacity:.7">SVC ${shortUUID(uuid)}: ${hex}</div>`;
            });
        }

        card.innerHTML = `
            ${d.isTarget ? `<div class="tag-target">${isCon ? '● CONNECTED' : '★ TARGET — TAP CONNECT'}</div>` : ''}
            <div class="dev-top">
                <span class="${name ? 'dev-name' : 'dev-name none'}">${name || '[ kein Name ]'}</span>
                <span class="dev-rssi" style="color:${col}">${d.rssi != null ? d.rssi : '—'}<small style="font-size:8px;font-weight:400"> dBm</small></span>
            </div>
            <div class="signal-bar" style="width:${pct}%;background:${col}"></div>
            <div class="dev-row">${tags}</div>
            ${mfrHex}${svcDataHex}
        `;
    }

    /* ═══════════════════════════════════════════════
       CONNECT FLOW
    ═══════════════════════════════════════════════ */
    async function connectDevice(id) {
        const entry = S.devs.get(id);
        if (!entry) return;

        const name = entry.bestName || 'Unbekannt';
        log(`Verbinde "${name}"…`);

        // Scan pausieren
        if (S.scanning) stopScan();

        try {
            // ── Breite Filter für den Chrome-Picker ──
            // acceptAllDevices als Fallback, damit das Gerät
            // IMMER im Picker erscheint — auch ohne Namen
            const filters = [];

            // Alle bekannten Namen als exakte Filter
            entry.names.forEach(n => {
                if (n && n.trim()) filters.push({ name: n });
            });

            // JBL-Produktnamen-Prefixe
            for (const prefix of ['JBL','jbl','Jbl','Yves','YVES','yves','Harman','HARMAN']) {
                filters.push({ namePrefix: prefix });
            }

            let requestOpts;
            if (filters.length > 0) {
                requestOpts = { filters, optionalServices: OPT_SERVICES };
            } else {
                requestOpts = { acceptAllDevices: true, optionalServices: OPT_SERVICES };
            }

            log('Chrome-Picker öffnet sich — Gerät auswählen.', 'warn');
            const device = await navigator.bluetooth.requestDevice(requestOpts);

            if (!device.gatt) {
                log('GATT nicht verfügbar.', 'error');
                return;
            }

            device.addEventListener('gattserverdisconnected', () => {
                log(`"${device.name || name}" getrennt.`, 'error');
                S.gattServer = null;
                S.gattDevice = null;
                S.connId = null;
                S.notifySubs = [];
                updateGattUI();
                renderCard(id);
                updatePill();
            });

            const server = await device.gatt.connect();
            S.gattServer = server;
            S.gattDevice = device;
            S.connId = id;

            // Name aus GATT-Device übernehmen (oft zuverlässiger)
            if (device.name) entry.names.add(device.name);
            entry.bestName = resolveBestName(entry.names);

            log(`GATT verbunden: "${device.name || name}"`, 'target');
            updateGattUI();
            renderCard(id);
            updatePill();
            goTab('tab-gatt');

            await enumerateGATT(server);

        } catch (e) {
            if (e.name === 'NotFoundError') {
                log('Picker abgebrochen.', 'warn');
            } else {
                log(`Connect-Fehler: ${e.message}`, 'error');
            }
        }
    }

    function disconnect() {
        S.notifySubs.forEach(n => { try { n.stopNotifications(); } catch(_){} });
        S.notifySubs = [];
        if (S.gattServer && S.gattServer.connected) {
            S.gattServer.disconnect();
            log('Getrennt.');
        }
        const prevId = S.connId;
        S.gattServer = null;
        S.gattDevice = null;
        S.connId = null;
        updateGattUI();
        if (prevId) renderCard(prevId);
        updatePill();
    }

    function updateGattUI() {
        const con = S.gattServer && S.gattServer.connected;
        document.getElementById('btn-dc').disabled = !con;
        document.getElementById('g-state').textContent = con ? 'Verbunden' : 'Nicht verbunden';
        document.getElementById('g-state').className = con ? 'val on' : 'val';
        const entry = S.connId ? S.devs.get(S.connId) : null;
        document.getElementById('g-name').textContent = entry ? (entry.bestName || S.connId) : '—';
        document.getElementById('g-name').className = entry?.isTarget ? 'val tgt' : 'val';
        if (!con) {
            document.getElementById('g-svcs').textContent = '—';
            document.getElementById('g-notify').textContent = '—';
            document.getElementById('gatt-list').innerHTML = '';
        }
    }

    /* ═══════════════════════════════════════════════
       GATT ENUMERATION
    ═══════════════════════════════════════════════ */
    async function enumerateGATT(server) {
        const container = document.getElementById('gatt-list');
        container.innerHTML = '';

        let services;
        try {
            services = await server.getPrimaryServices();
        } catch (e) {
            log(`getPrimaryServices: ${e.message}`, 'error');
            return;
        }

        log(`${services.length} GATT-Services gefunden.`);
        document.getElementById('g-svcs').textContent = services.length;

        for (const svc of services) {
            const svcShort = svc.uuid.substring(4, 8);
            const svcName = SVC_NAMES[svc.uuid.substring(0,8)] || shortUUID(svc.uuid);

            const svcEl = document.createElement('div');
            svcEl.className = 'gatt-svc';
            svcEl.innerHTML = `<div class="gatt-svc-head">⬡ ${svcName}<small>${svc.uuid}</small></div>`;
            container.appendChild(svcEl);
            log(`  SVC: ${svcName}`);

            let chars;
            try { chars = await svc.getCharacteristics(); }
            catch (e) { log(`  Chars err: ${e.message}`, 'error'); continue; }

            for (const ch of chars) {
                const chShort = ch.uuid.substring(4, 8);
                const chName = CHAR_NAMES[chShort] || chShort.toUpperCase();
                const flags = propFlags(ch.properties);
                const valId = `v_${ch.uuid.replace(/-/g,'')}`;

                let badges = '';
                if (ch.properties.notify) badges += '<span class="badge notify">NOTIFY</span>';
                if (ch.properties.indicate) badges += '<span class="badge indicate">IND</span>';

                const chEl = document.createElement('div');
                chEl.className = 'gatt-char';
                chEl.innerHTML = `
                    <span class="gatt-char-name">${chName}</span>${badges}
                    <div class="gatt-char-flags">${flags}</div>
                    <div class="gatt-char-uuid">${ch.uuid}</div>
                    <span class="gatt-val" id="${valId}">…</span>
                `;
                svcEl.appendChild(chEl);

                if (ch.properties.read) readVal(ch, valId);
                if (ch.properties.notify || ch.properties.indicate) subscribe(ch, valId, chName);
            }
        }

        document.getElementById('g-notify').textContent = S.notifySubs.length;
        log('GATT Enumeration abgeschlossen.', 'target');
    }

    async function readVal(ch, valId) {
        try {
            const dv = await ch.readValue();
            renderVal(dv, valId);
            log(`    READ ${shortUUID(ch.uuid)}: ${formatDV(dv)}`);
        } catch (e) {
            const el = document.getElementById(valId);
            if (el) el.textContent = `ERR: ${e.message}`;
        }
    }

    async function subscribe(ch, valId, label) {
        try {
            ch.addEventListener('characteristicvaluechanged', ev => {
                renderVal(ev.target.value, valId);
                log(`  ⚡ ${label}: ${formatDV(ev.target.value)}`, 'target');
            });
            await ch.startNotifications();
            S.notifySubs.push(ch);
            log(`    ✓ Sub: ${label}`, 'target');
        } catch (e) {
            log(`    Sub-err ${label}: ${e.message}`, 'error');
        }
    }

    /* ═══════════════════════════════════════════════
       VALUE RENDERING
    ═══════════════════════════════════════════════ */
    function renderVal(dv, elId) {
        const el = document.getElementById(elId);
        if (!el) return;
        const bytes = safeBytes(dv);
        const hex = bytesToHex(bytes);
        const text = decodeText(bytes);

        if (bytes.length === 0) {
            el.textContent = '(empty)';
        } else if (bytes.length === 1) {
            el.textContent = `${bytes[0]}  [0x${hex}]`;
        } else if (text && /^[\x20-\x7E]+$/.test(text)) {
            el.textContent = `"${text}"  [${hex}]`;
        } else {
            el.textContent = `[${hex}]`;
        }
    }

    function formatDV(dv) {
        const bytes = safeBytes(dv);
        const hex = bytesToHex(bytes);
        const text = decodeText(bytes);
        if (text && /^[\x20-\x7E]+$/.test(text)) return `"${text}" [${hex}]`;
        return `[${hex}]`;
    }

    /* ═══════════════════════════════════════════════
       UTIL
    ═══════════════════════════════════════════════ */
    function safeBytes(dv) {
        return new Uint8Array(dv.buffer, dv.byteOffset, dv.byteLength);
    }
    function bytesToHex(bytes) {
        return Array.from(bytes).map(b => b.toString(16).padStart(2,'0')).join(' ');
    }
    function decodeText(bytes) {
        try { return new TextDecoder('utf-8', { fatal: false }).decode(bytes); }
        catch(_) { return null; }
    }
    function shortUUID(uuid) {
        if (!uuid) return '?';
        if (typeof uuid === 'number') return '0x' + uuid.toString(16).toUpperCase().padStart(4,'0');
        const s = String(uuid);
        if (s.endsWith('-0000-1000-8000-00805f9b34fb')) return '0x' + s.substring(4,8).toUpperCase();
        return s.substring(0,8) + '…';
    }
    function propFlags(p) {
        const f = [];
        if (p.read) f.push('R');
        if (p.write) f.push('W');
        if (p.writeWithoutResponse) f.push('W_NR');
        if (p.notify) f.push('N');
        if (p.indicate) f.push('I');
        if (p.broadcast) f.push('BC');
        return f.join(' · ') || '—';
    }

    /* ═══════════════════════════════════════════════
       LOG EXPORT
    ═══════════════════════════════════════════════ */
    function exportLog() {
        const header = `BLE YVES LOG — ${new Date().toISOString()}\nDevices seen: ${S.devs.size}\n${'═'.repeat(60)}\n\n`;
        const devDump = [...S.devs.values()].map(d =>
            `${d.bestName || '(no name)'} | target:${d.isTarget} | rssi:${d.rssi} | count:${d.count} | mfr:[${[...d.mfr.keys()].map(k=>'0x'+k.toString(16)).join(',')}]`
        ).join('\n');
        const logDump = S.logs.map(e => `[${e.ts}] [${e.type||'info'}] ${e.msg}`).join('\n');
        const blob = new Blob([header + 'DEVICES:\n' + devDump + '\n\nLOG:\n' + logDump], { type: 'text/plain' });
        const a = document.createElement('a');
        a.href = URL.createObjectURL(blob);
        a.download = `BLE_YVES_${Date.now()}.txt`;
        a.click();
        URL.revokeObjectURL(a.href);
        log('Log exportiert.');
    }

    function clearLog() {
        S.logs = [];
        document.getElementById('log-list').innerHTML = '';
    }

    /* ═══════════════════════════════════════════════
       PUBLIC
    ═══════════════════════════════════════════════ */
    return { startScan, stopScan, connectDevice, disconnect, tab, exportLog, clearLog };
})();
</script>
</body>
</html>
